package VulnerabilityDetector;

import java.util.Map;
import java.lang.reflect.Method;
import java.util.List;
import org.json.simple.JSONObject;
import Tools.*;
import com.profesorfalken.jpowershell.PowerShell;
import com.profesorfalken.jpowershell.PowerShellNotAvailableException;
import com.profesorfalken.jpowershell.PowerShellResponse;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.InvocationTargetException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Víctor Rebollo Pérez
 */
/*
Cada test tiene un nombre, un código para testear información // En función del SO se ejecutará de una forma u otra
Recogera el String y lo formateará en un formato legible creando mensajes de aviso seguridad y todo eso
*/


/*VulnerabilityScan tiene biblioteca de test que puede ejecutar en cada sistema operativo*/
/*List<Vulnerability> lista_Vulnerabilidades*/
public class Test {
    //List<String> SO;
    String VulnerabilityID;
    String VulnerabilityName;
    Map CommandExecuter;
    Map Commands;
    //JSONObject Commands; 
    TestResult result;
    List<String> tier;
    
    public Test(Map testData){
        //SO = (List<String>) testData.get("SO");
        VulnerabilityID =  (String) testData.get("VulnerabilityID");
        VulnerabilityName =  (String) testData.get("VulnerabilityName");
        CommandExecuter =  (Map) testData.get("CommandExecuter");
        Commands = (JSONObject) testData.get("Commands");
        tier = (List<String>) testData.get("Tier");
    }
    TestResult runTest(String SO) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, IOException{
        
        System.out.println("RUN TESTS ");
        result = new TestResult();
        result.vulnerabilityName  = VulnerabilityName;
        Date date = new Date();     
        SimpleDateFormat formatter = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss");
        result.date = formatter.format(date);
        result.tier = tier;
        List<String> output =  new ArrayList<String>();
        String used_OS = SO.toLowerCase();
        long start = System.currentTimeMillis();
        boolean supported_test = true;
        
        /*
        CommandExecuter: Windows, Ubuntu, All
        */

        
        if(CommandExecuter.containsKey("All")){
           if(this.CommandExecuter.get("All") != null){
            tools t = new tools();
            List<String> commands = (List<String>) Commands.get("java");
            for (String command : commands) {
                Method m = Tools.tools.class.getMethod(command);
                output.add((String) m.invoke(t));
                }
            }          
        }

        else if(used_OS.contains("windows")){
            if(CommandExecuter.containsKey("Windows")){
                if(((String) CommandExecuter.get("Windows")).contains("powershell")){
                    List<String> commands = (List<String>) ((Map) (Commands.get("powershell"))).get("test");    
                    for (String command : commands) {
                        System.out.println("---------------Command :  "   + command);
                        String command_output = "";
                        String powershell =  "powershell.exe ";
                        String final_command = powershell + command;
                        Process bash = Runtime.getRuntime().exec(final_command);
                        bash.getOutputStream().close();
                        String line;
                        BufferedReader stdout = new BufferedReader(new InputStreamReader(
                        bash.getInputStream()));
                        while ((line = stdout.readLine()) != null) {
                            command_output += line;
                        }
                        stdout.close();
                        BufferedReader stderr = new BufferedReader(new InputStreamReader(
                        bash.getErrorStream()));
                        while ((line = stderr.readLine()) != null) {
                            System.out.println("Line   "  + line);
                        }
                        System.out.println("Command output    " + command_output);
                        output.add((String) command_output);                     
                    }          
               }  
            }
            else{
                 supported_test = false;
            }
        }
  
        else if(used_OS.contains("linux")){
            if(CommandExecuter.containsKey("Linux")){
                if(((String) CommandExecuter.get("linux")).contains("bash")){
                    List<String> commands = (List<String>) ((Map) (Commands.get("bash"))).get("test");
                    for (String command : commands) {
                        String command_output = "";
                        String powershell =  "/bin/bash";
                        String final_command = powershell + command;
                        Process bash = Runtime.getRuntime().exec(final_command);
                        bash.getOutputStream().close();
                        String line;
                        BufferedReader stdout = new BufferedReader(new InputStreamReader(
                        bash.getInputStream()));
                        while ((line = stdout.readLine()) != null) {
                            command_output += line;
                        }
                        stdout.close();
                        BufferedReader stderr = new BufferedReader(new InputStreamReader(
                        bash.getErrorStream()));
                        /*while ((line = stderr.readLine()) != null) {
                            System.out.println(line);
                        }*/
                        output.add((String) command_output);       
                        } 
                    }
                }
            else{
                supported_test = false;
            }
        }
        
        long end = System.currentTimeMillis();
        long interval = end - start;
        result.timeElapsed = "0." + Long.toString(interval);
        
        if(!supported_test){
            output.add((String) "Not supported test");       
        }
        else{
            result.output = output;
            createResult();
        }
        return result;
    }
    TestResult getResult(){
        return result;
    }
    void createResult(){
        for(int i = 0 ; i < result.output.size();i++){
                    result.message += result.output.get(i) + "\n\n\n";
        }
    }
    public String getName(){
        return VulnerabilityName;
    }
}




